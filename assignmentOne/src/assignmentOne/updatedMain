/*
 * Authors: Connor Morrison, Chris Miller
 * Date:12/06/17
 * Overview: This program creates a Huffman Tree from a text document, encodes the document, then decodes it.
 * */
package assignmentOne;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.Stack;





class Node{
	public Node leftNode;
	public Node rightNode;
	public int freq;
	public String id;
	
	public boolean hasChild()
	{
		if(leftNode != null || rightNode != null)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
}


class Tree{
	public Node root;
	public Tree(){
		root =null;
	}
	
	public void makeTree(Node n)
	{
		root = n;
	}
	private Node getSuccessor(Node delNode) {
		Node successorParent = delNode;
		Node successor = delNode;
		Node current = delNode.rightNode;        // go to the right child
		while (current != null) {                 // until no more
			successorParent = successor;          // left children
			successor = current;
			current = current.leftNode;
		}

		if (successor != delNode.rightNode) {    // if successor not right child,
			//make connections
			successorParent.leftNode = successor.rightNode;
			successor.rightNode = delNode.rightNode;
		}
		return successor;
	}
	public Node find(int key, String id) {      // find node with given key
		Node current = root;
		String num = "";
		// (assumes non-empty tree)
		while (current.freq != key && current.id != id) {          // while no match
			if (key < current.freq) {          // go left?
				current =  current.leftNode;
				num+="0";
			}
			else {                              // or go right?
				current =  current.rightNode;
				num+="1";
			}
			if(current == null)                 // if no child
			{                                   // didn't find it
				return null;              
			}			
		}
		System.out.println(num);
		return current;                         // found it
	}  //end find()
	
	/*
	public boolean delete(String key) {             // delete node with given key
		Node current = root;		             // (assumes non-empty list)
		Node parent = root;
		boolean isleftNode = true;

		while (current.id != key) {           // search for Node
			parent = current;
			if (key < current.id) {           // go left?
				isleftNode = true;
				current =  current.leftNode;
			}
			else {                               // or go right?
				isleftNode = false;
				current =  current.rightNode;
			}
			if(current == null) {                // end of the line,                             
				return false;                    // didn't find it
			}			
		}
		//found the node to delete

		//if no children, simply delete it
		if (current.leftNode == null && current.rightNode == null) {
			if (current == root) {              // if root,
				root = null;                    // tree is empty
			}
			else if (isleftNode) {
				parent.leftNode = null;        // disconnect
			}                                   // from parent
			else {
				parent.rightNode = null;
			}
		}
		//if no right child, replace with left subtree
		else if (current.rightNode == null) {  
			if (current == root) {
				root = current.leftNode;
			}
			else if (isleftNode) {
				parent.leftNode = current.leftNode;
			}			
			else {
				parent.rightNode = current.leftNode;
			}
		}

		//if no left child, replace with right subtree
		else if (current.leftNode == null) {  
			if (current == root) {
				root = current.rightNode;
			}
			else if (isleftNode) {
				parent.leftNode = current.rightNode;
			}			
			else {
				parent.rightNode = current.rightNode;
			}
		}

		else { // two children, so replace with inorder successor
			   // get successor of node to delete (current)
			Node successor = getSuccessor(current);

			// connect parent of current to successor instead
			if (current == root) {
				root = successor;
			}
			else if (isleftNode) {
				parent.leftNode = successor;
			}
			else {
				parent.rightNode = successor;
			}

			//connect successor to current's left child
			successor.leftNode = current.leftNode;
		} // end else two children
		// (successor cannot have a left child)
		return true;              // success
	}// end delete()
	*/
	public void insert(String id, int freq){
		Node node = new Node();
		node.id = id;
		node.freq = freq;
		node.leftNode = null;
		node.rightNode = null;
		if(root ==null){
			root = node;
		}else{
			Node current = root;
			Node parent;
			while(true){
				parent = current;
				if(freq < current.freq){
					current = current.leftNode;
					if(current == null) {             // if the end of the line        
						parent.leftNode = node;   // insert on left
						return;                    
					}
				}else{
					current = current.rightNode;
					if(current == null){
						parent.rightNode = node;
						return;    
					}
				}
			}
		}
	}
	String number = "";
	int checked = 0;
	ArrayList<String> codes = new ArrayList<String>();
	ArrayList<String> id = new ArrayList<String>();
	int count = 0;
	public void codeTable(Node localRoot,String code)
    {
        if (localRoot!=null)
        {   
            if (localRoot.leftNode!=null){
            	codeTable(localRoot.leftNode, code+"0");
            }
            if (localRoot.rightNode!=null){   
            	codeTable(localRoot.rightNode,code+"1");
            }
            else{
                //System.out.println(code);
                codes.add(code);
                id.add(localRoot.id);
            }
        }       
    }
	String[][] codeT;
	public void constructCodeTable(int size){
		codeT = new String[size][2];
		System.out.println("Code Table");
		System.out.println("----------");
		for(int i =0; i < codes.size(); i++){
			codeT[i][0] = id.get(i);
			codeT[i][1] = codes.get(i);
			System.out.print(codeT[i][0] + "    " + codeT[i][1]);
			System.out.println("");
		}
	}
	public String displayEncode(String origText){
		String encoded = "";
		String brokenEncoded = "";
		String[] brokenUp = origText.split("");
		for(int i = 0; i < brokenUp.length; i++){
			for(int x = 0; x < id.size(); x++){
				if(brokenUp[i].equals(id.get(x))){
					encoded+=codes.get(x);
					brokenEncoded+= codes.get(x)+" ";
				}
			}
		}
		System.out.println(encoded);
		return brokenEncoded;
	}
	public String decode(String encoded){
		String decoded = "";
		String brokenDecoded = "";
		String[] brokenUp = encoded.split(" ");

		for(int i = 0; i < brokenUp.length; i++){
			for(int x = 0; x < codes.size(); x++){
				if(brokenUp[i].equals(codes.get(x))){
					decoded+=id.get(x);
					brokenDecoded+= id.get(x);
				}
			}
		}
		System.out.println(brokenDecoded);
		return brokenDecoded;

	}
	public void preOrder(Node localRoot,String add) {
		number += add;
		if (localRoot != null) {
				if(localRoot.id != null){
					System.out.println(count);
					System.out.println(number);
					System.out.println(localRoot.id);
					number ="";
				}
				count+=1;
				preOrder(localRoot.leftNode, "0");
				count+=1;
				preOrder(localRoot.rightNode, "1");	

			}
		}
	
	

	public void displayTree() {
		Stack<Node> globalStack = new Stack<Node>();
		globalStack.push(root);
		int nBlanks = 32;
		boolean isRowEmpty = false;
		System.out.println(".................................................................");
		while (isRowEmpty==false) {
			Stack<Node> localStack = new Stack<Node>();
			isRowEmpty = true;
			
			for (int j = 0; j < nBlanks; j++) {
				System.out.print(' ');
			}

			while (globalStack.isEmpty()==false) {
				Node temp = (Node) globalStack.pop();
				if (temp != null) {
					System.out.print(temp.id);
					localStack.push(temp.leftNode);
					localStack.push(temp.rightNode);
					if (temp.leftNode != null ||
							temp.rightNode != null) {
						isRowEmpty = false;
					}
				}
				else {
					System.out.print("--");
					localStack.push(null);
					localStack.push(null);
				}

				for (int j = 0; j < nBlanks*2-2; j++) {
					System.out.print(' ');
				}
			} // end while globalStack not empty
			System.out.println();
			nBlanks /= 2;
			while (localStack.isEmpty()==false) {
				globalStack.push(localStack.pop());
			} // end while isRowEmpty is false
			System.out.println(
			".................................................................");
		} // end displayTree()
	} // end class Tree
}
public class main {
	public static void main(String[] args)throws IOException{
		Tree theTree = new Tree();
		Comparator<Node> comparator = new NodeComparator();
		// TODO Auto-generated method stub
		File input = new File("input.txt");
		File output = new File("output.txt");
		BufferedReader br = new BufferedReader(new FileReader(input));
		FileWriter fp = new FileWriter(output);
		//[rows][columns]
		String[][] multi = new String[][]{
			  { " ", "0"},
			  { "a", "0"},
			  { "b", "0"},
			  { "c", "0"},
			  { "d", "0"},
			  { "e", "0"},
			  { "f", "0"},
			  { "g", "0"},
			  { "h", "0"},
			  { "i", "0"},
			  { "j", "0"},
			  { "k", "0"},
			  { "l", "0"},
			  { "m", "0"},
			  { "n", "0"},
			  { "o", "0"},
			  { "p", "0"},
			  { "q", "0"},
			  { "r", "0"},
			  { "s", "0"},
			  { "t", "0"},
			  { "u", "0"},
			  { "v", "0"},
			  { "w", "0"},
			  { "x", "0"},
			  { "y", "0"},
			  { "z", "0"},
			  { "A", "0"},
			  { "B", "0"},
			  { "C", "0"},
			  { "D", "0"},
			  { "E", "0"},
			  { "F", "0"},
			  { "G", "0"},
			  { "H", "0"},
			  { "I", "0"},
			  { "J", "0"},
			  { "K", "0"},
			  { "L", "0"},
			  { "M", "0"},
			  { "N", "0"},
			  { "O", "0"},
			  { "P", "0"},
			  { "Q", "0"},
			  { "R", "0"},
			  { "S", "0"},
			  { "T", "0"},
			  { "U", "0"},
			  { "V", "0"},
			  { "W", "0"},
			  { "X", "0"},
			  { "Y", "0"},
			  { "Z", "0"},
			};
		
		
		//counting the components.
		/*
		 *  x Accept a text message.
			x Construct a frequency table for the message.
			Create a Huffman tree for this message.
			Create a code table.
			Encode the message into binary
			Decode the message from binary back to text.
		 * 
		 * */
		String text = br.readLine();
		System.out.println(text);
		String[] comps = text.split("");
		String[] compon = {" ", "a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"};
		String[] compon2 = {"A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"};
		for(int i2 = 0; i2 < comps.length; i2++){
			for(int w2 = 0; w2<compon.length; w2++){
				if(comps[i2].equals(compon[w2])){
					int val = Integer.parseInt(multi[w2][1]);
					val+=1;
					multi[w2][1] = String.valueOf(val);
				}
			}
			for(int x2 = 0; x2<compon2.length; x2++){
				//capital letters
				if(comps[i2].equals(compon2[x2])){
					int val = Integer.parseInt(multi[x2+27][1]);
					val+=1;
					multi[x2+27][1] = String.valueOf(val);
				}
			}
		}
		String[] id = new String[30];
		int[] freqCount = new int[30];
		//count nums in prog
		int counter =0;
		for(int w3 = 0; w3 < multi.length; w3++){
			if(Integer.parseInt(multi[w3][1])>0){
				id[counter] = multi[w3][0];
				freqCount[counter] = Integer.parseInt(multi[w3][1]);
				//System.out.println(id[counter]);
				counter++;
			}
		}
		String[][] finTable = new String[id.length][2];
		int totalLetters = 0;
	    System.out.println("Frequency Table");
	    System.out.println("---------------");
		System.out.println("CHAR   COUNT");
		for(int t4 = 0; t4 < id.length; t4++){
			if(id[t4] != null){
				finTable[t4][0] = id[t4];
				finTable[t4][1] = String.valueOf(freqCount[t4]);
				totalLetters++;
				System.out.println(finTable[t4][0] + "      " + finTable[t4][1]);
				
			}
		}
		System.out.println("Total letters: " + totalLetters);
		//priority Queue(total number of letters, comparator)
		PriorityQueue<Node> theQueue = new PriorityQueue<Node>(totalLetters, comparator);
		for(int t5 = 0; t5 < id.length; t5++) {
			if(id[t5] != null){
				Node queueAdder = new Node();
				queueAdder.id = finTable[t5][0];
				queueAdder.freq = Integer.parseInt(finTable[t5][1]);
				theQueue.add(queueAdder);
			}
		}
		
		Node iterator1 = new Node();
		Node iterator2 = new Node();
		while(!(theQueue.isEmpty()))
		{
			if(theQueue.size() == 1)
			{
				break;
			}
			iterator1 = theQueue.poll ();
			iterator2 = theQueue.poll();
			Node iterator3 = new Node(); 
			iterator3.freq = iterator1.freq + iterator2.freq;
			iterator3.leftNode = iterator1;
			iterator3.rightNode = iterator2;
			theQueue.add(iterator3);
		}
		theTree.makeTree(theQueue.poll());
		theTree.displayTree();
		//theTree.preOrder(theTree.root,"0");
		//System.out.println(theTree.find(1, "T").id);
		theTree.codeTable(theTree.root, "");
		theTree.constructCodeTable(theTree.codes.size());
		String encoded = theTree.displayEncode(text);
		String decoded = theTree.decode(encoded);
		fp.write(decoded);
		fp.close();
	}
	

}
	
class NodeComparator implements Comparator<Node>
{
	public int compare(Node x, Node y)
	{
		if(x.freq < y.freq)
		{
			return -1;
		}
		if(x.freq > y.freq)
		{
			return 1;
		}
		if(x.freq == y.freq&& x.hasChild())
		{
			return -1;
		}
		if(x.freq == y.freq&& y.hasChild())
		{
			return 1;
		}
		else 
		{
			return 0;
		}
	}
	
}
